==========================================
Validation Tests for Core Coarray Features
==========================================

Tests may be broadly classified as:

* Feature Test:     validates acceptance of a feature and correctness of its
                    implementation
* Restriction Test: expects compile-time or run-time check for a particular
                    violation of the Fortran 2008 standard.

Keys:
##: need to think of an method of verifying the correctness
@@: compiler needs to accept such code
$$: error can be detected only during execution time
??: is it in the Fortran 2008 standard?

Test Categories:

* Referencing Other Images

  Feature tests:
  - this_image: this_image()
       this_image(z [,dim])
  - num_images:
       num_images()
  - image_index:
       image_index(z, sub)


* Properties of Coarrays

  Feature tests:
  - a coarray declared with the codimension keyword or the [] @@
  - a coarray may be allocatable ## (are references to
    deallocated-allocatables undefined???)
  - allow declaration of array or scalar coarrays @@
  - allow coarrays of both basic and derived types. @@
  - every coarray has a final coextent, final upper cobound, and a coshape
    based on the number of images the program is run with ##

  Some restrictions:
  - a coarray should not be a named constant
  - cosubscripts are not permitted in data statements
  - a coarray is not permitted to be a pointer
  - a coarray is not permitted to be of type c_ptr or c_funptr

* Accessing Coarrays

  Feature Tests:
  - a coarray (which includes subobjects of declared coarray variables) on
    another image may be read from using cosubscripts
  - referencing an object without square brackets refers to the object on the
    executing image $$
  - coindexed objects are permitted in intrinsic operations, intrinsic
    assignments $$
  - coindexed objects are permitted in input/output lists ##
  - a coindexed object is permitted as an actual argument corresponding to a
    non-coarray dummy argument in a procedure invocation @@
  - a coarray is permitted as the selector in an associate or select type
    statement ##

  Some restrictions:
  - cosubscripts for a coindexed object should be valid, meaning they map to
    an image index between 1 and num_images() (programmer's responsibility)
  - a polymorphic subobject may not be coindexed (?)
  - pointers are not allowed to have targets on remote images (compile-time
    check)
  - a coindexed object is not permitted as the selector in an associate or
    select type statement

  ?? a coindexed object is not finalized if it occurs as the left-hand side of
  an intrinsic assignment or as an actual argument corresponding to an
  intent(out) dummy argument.


* Coarrays in Procedures

  Feature tests:
  - a dummy argument is permitted to be a coarray of explicit shape, assumed
    size, assumed shape, or allocatable @@
  - each image defines the corank and cobounds afresh for its non-allocatable
    coarray dummy arguments ##


  Some restrictions:
  - when a procedure with a dummy coarray argument is called, the
    corresponding actual argument must be a coarray
  - the interface for such a procedure (^) is required to be explicit
  - if a dummy argument is an array coarray that is not of assumed shape or is
    of assumed shape and has the contiguous attribute (new in F2008), the
    actual argument must be "simply contiguous"
  - if a dummy argument is a coarray or has a component that is an allocatable
    coarray, it must not have the value attribute
  - if a dummy argument is an allocatable coarray, the corresponding actual
    argument must be an allocatable coarray of the same rank and corank
  - an allocatable dummy argument must be associated, through arbitrary number
    of levels of procedure call, with the same non-dummy-argument coarray on
    every image.
  - a dummy argment that is an allocatable coarray or has a component that is
    an allocatable coarray must not have intent(out)
  - automatic coarrays are not permitted
  - a function result is not permitted to be a coarray or be of a type that
    has a coarray component at any level of component selection.
  - a pure or elemental procedure is not permitted to define a coindexed
    object or contain any image control statements
  - an elemental procedure is not permitted to have a coarray dummy argument
  - unless it is allocatable or a dummy argument, an object that is a coarray
    or has a coarray component is required to have the save attribute
    (variables declared in specification part of modules or submodules, or in
    main program, automatically have save attribute)


* Volatile and Asynchronous Attributes ##


  Some restrictions:
  - the volatility of a dummy coarray must agree with the volatility of the
    corresponding actual argument
  - volatility for a coarray accessed via use association, host association,
    or an accessed coarray defined in a block construct must not be
    respecified (??)
  - volatility agreement is required for pointer association with any part of
    a coarray
  - if the actual argument is a coindexed object, the dummy argument is not
    permitted to have the asynchronous or volatile attribute


* Interoperability ##

  Interoperability of coarrays with C or UPC is not required.


* Storage Association ##

  Some restrictions:
  - coarrays not permitted in common and equivalence statements

* Allocatable Coarrays

  Feature tests:
  - allocate statement is extended so that cobounds may be specified ##
  - executing image will block at an allocate statement until all images
    finish execute the _same_ allocate statement (same line of the source
    code) $$ ##
  - executing image will block at a deallocate statement until all images have
    begin execution of the same deallocate statement $$
  - implicit deallocation and synchronization occurs on exit of a procedure or
    block for allocatable coarrays that don't have the save attribute $$ ##

  Some restrictions:
  - cobounds must be specified in an allocate statement when allocating a
    coarray, and the upper bounds for the final codimension must be an
    asterisk.
  - the value of each bound, cobound, or length type parameter is required to
    be the same on all images (run-time constraint)
  - dynamic type for coarrays must be the same on all images
  - allocation of a polymorphic coarray is not permitted to create a coarray
    that is of type c_ptr, c_funptr, or of a type with a coarray ultimate
    component (??)
  - the shape and length parameters must not disagree on the two sides of an
    intrinsic array assignment to an allocatable coarray


* Coarrays with allocatable or pointer components

  Feature tests:
  - a coarray is permitted to be of a derived type with allocatable or pointer
    components @@
  - a coarray of derived type may have a non-coarray allocatable or pointer
    components which may be associated to different sized memory locations on different images. ##
  - a component of a derived type can be a coarray only if the component is ALLOCATABLE
  - If an object with an allocatable coarray component is declared without the
    save attribute in a procedure and the coarray is still allocated on return, there is an implicit
    deallocation and associated synchronization. ##
  - Similarly, if such an object is declared within a
    block construct and the coarray is still allocated when the block completes execution, there is an
    implicit deallocation and associated synchronization. ##

  Some restrictions:
  - a coarray is not permitted to be of a derived type with components of type
    c_ptr or c_funptr)
  - a local pointer may not be assocated with a target component on another
    image
  - allocating a pointer or an allocatable component of a coarray of derived
    type on another image is not allowed
  - if an actual argument is a coindexed object with an allocatable ultimate
    component and the correspondgin dummy argument is niether allocatable nor
    a pointer, the dummy argument must have INTENT IN or the VALUE attribute.
  - at any level of component selection, each ancestor of the coarray
    component must be a non-allocatable , non-pointer, non-coarray scalar.
  - To avoid the possibility of implicit reallocation in an intrinsic
    assignment for a scalar of a derived type with an allocatable coarray component, no disagreement of allocation
    status or shape is permitted for the coarray component.
  - It is not permissible to add a coarray component by type extension unless
    the type already has one or more coarray components.

* References to polymorphic subobjects (??)

  Feature tests:
  - no references are permitted to polymorphic sub-oobjects to conindexed
    objects or objects with objects with allocatable subcomponent

  Some restrictions:


* Synchronization

  Feature tests:
  - sync all statement provides a barrier $$
  - SYNC ALL(stat=) SYNC ALL(errmsg=) @@ ##
  - sync images(image_set) indicates synchronization of executing image with
    image indices listed in images-set $$ ## (is there a better option other
    than using sleep())
  - The image executing sync images(*) implies that the image synchronizes
    with other images but it does not mean that all the other images synchronize
    with each other.
  - SYNC IMAGES(stat=) SYNC IMAGES(errmsg=)
  - a lock is a scalar variable of derived type lock_type that is **defined in
    the intrinsic module iso_fortran_env**. ##
  - LOCK and UNLOCK statements @@
  - LOCK statement that avoids wait: LOCK(lock_var, stat=) and  LOCK(lock_var,errmsg=) ##(how to check for wait)
  - CRITICAL sections.
  - SYNC MEMORY(stat=) SYNC MEMORY(errmsg=) ##

  Some restrictions:
  - 'image-set' in 'sync images(image_set)' must be an integer array of rank 1 or
    an asterisk '*'
  - The 'lock_type' has private components that are not pointer and not allocatables.
  - if a lock variable is a dummy argument or a subobject of a dummy argument, the
    dummy argument must not have INTENT OUT ##
  - For a sourced allocation of a coarray (using source= to take its value
    from another variable or expression), the source is not permitted to have type lock type or have a
    subcomponent of this type because this might create a new lock that is not unlocked initially. ##
  - No image-control statement must me execute within a critical section @@ 
  - No CALL statement may be executed within a critical section @@



* Program termination

  Feature tests:
  - When executed on one image, ERROR STOP initiates error termination there and
    hence causes all other images that have not already initiated error
    termination to initiate error-termination.

  Some restrictions:


* Input/output ##

  Feature tests:
  - The default unit for input ('*' in a read statement or input unit in the
    intrinsic module iso_fortran_env) is preconnected on image one only. ##
  - The default unit for output ('*' in a write statement or output unit in the
    intrinsic module iso_fortran_env) and the unit that is identified by error unit in the
    intrinsic module iso_fortran_env are preconnected on each image. ##

  Some restrictions:


* Intrinsic procedures

  Feature tests:
  - image_index(coarray, sub) returns a default integer scalar. ## If sub holds a
    valid sequence of cosubscripts for coarray, the result is the corresponding image index.i ## (need to confirm)
    Otherwise, the result is zero $$
  - lcobound(coarray [,dim] [,kind]) returns the lower cobounds of a coarray
    in just the same way as lbound returns the lower bounds of an array. $$
  - ucobound(coarray [,dim] [,kind]) returns the upper cobounds of a coarray
    in just the same way as ubound returns the upper bounds of an array. $$
  - num images() returns the number of images as a default integer scalar. $$
  - this image() returns the index of the invoking image as a default integer scalar. $$
  - this image(coarray[,dim]) returns the set of cosubscripts of coarray that
    denotes data on the invoking image. $$
  Where,
  'dim' is scalar integer whose value is in the range 1 to n where
  n is the corank of coarray.
  If dim is absent, the result is a default integer array of rank one and size
  equal to the corank of coarray; it holds the set of cosubscripts of coarray for data on the
  invoking image. If dim is present, the result is a default integer scalar holding
  cosubscript dim of coarray for data on the invoking image.

  - Atomic subroutines
    -- atomic define(atom,value) defines atom atomically with the value 'value'. ##
       'atom' is a scalar coarray or coindexed object of type integer(atomic int kind)
       or logical(atomic logical kind) and intent(out). If its kind is the same as that
       of value or its type is logical, it is given the value of value. Otherwise, it
       is given the value int(value,atomic int kind).
       'value' is a scalar of the same type as atom and intent(in).
    -- atomic ref(value,atom) defines value atomically with the value of atom. ##
       'value' is a scalar of the same type as atom and intent(out). If its kind is the
       same as that of atom or its type is logical, it is given the value of atom. Otherwise,
       it is given the value int(atom,kind(value)).
       'atom' is a scalar coarray or coindexed object of type integer(atomic int kind)
       or logical(atomic logical kind) and intent(in).

  Some restrictions:


